{"version":3,"sources":["webpack://Awezoom/webpack/universalModuleDefinition","webpack://Awezoom/webpack/bootstrap","webpack://Awezoom/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","lastTime","vendors","x","length","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","id","setTimeout","clearTimeout","running","runCallback","throttledResize","optimizedResize","addResizeListener","handleResize","addEventListener","removeResizeListener","removeEventListener","hasOwnProp","parseSettings","settings","_typeof","defaultSettings","zoomLevel","minZoomLevel","maxZoomLevel","zoomFactor","alignment","horizontal","vertical","zoomEasing","zoomDuration","focalPoint","y","beforeZoomCallback","afterZoomCallback","resultSettings","prop","setCSSStyles","element","styles","style","undefined","vendorPrefixes","styleName","toUpperCase","substr","getTransitionEndEvent","document","createElement","transitions","transition","oTransition","mozTransition","webkitTransition","transitionEndEvent","valueBetween","min","console","warn","Awezoom","_this","this","_classCallCheck","zoomContainerElement","querySelector","nodeType","children","innerHTML","zoomContentElement","placeholderElement","appendChild","overflow","position","transform","transformOrigin","state","isZooming","zoomContainerSize","contentSize","contentOffset","scrollPosition","update","zoom","calculateZoomContainerSize","calculateContentSize","calculateScrollPosition","arguments","currentZoomLevel","currentZoomContainerSize","currentContentSize","targetContentOffset","determineIntendedContentOffset","width","height","transitionDuration","transitionTimingFunction","_this2","currentContentOffset","currentScrollPosition","zoomedContentSize","targetTransformOrigin","determineTransformOrigin","contentOffsetAfterZooming","focalPointInZoomedContent","findRawCoordinatesInZoomedContent","viewportCoordinates","findRawCoordinatesInViewport","maxScrollPosition","newScrollPosition","transformOffsetToCompensateOrigin","transformOffset","setScrollPosition","afterTransition","replace","triggerReflow","unzoomedContentSize","widthFactor","heightFactor","offsetHeight","clientWidth","clientHeight","offsetWidth","coordinates","coordinatesInUnzoomedContent","scrollLeft","scrollTop","alignmentSettings","availableSpace","focalPointInUnzoomedContent","findViewportCoordinatesInRawContent","zoomContainerSizeAroundFocalPoint","top","right","bottom","left","newZoomLevel","targetFocalPoint","contentMarginAfterZooming","determineContentMargin","pinchEventType","scale","_this3","lastPinchFocalPoint","lastPinchOffset","lastPinchOrigin","lastPinchZoomLevel"],"mappings":"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","file":"awezoom.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Awezoom\"] = factory();\n\telse\n\t\troot[\"Awezoom\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n* awezoom v1.0.1\n* https://github.com/JohannUlbrich/awezoom\n*\n* Copyright (c) 2016 Johann Ulbrich <info@johann-ulbrich.de>\n* Released under the MIT license\n*\n* Date: 2018-03-18\n*/\n\n// requestAnimationFrame polyfill\n// http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n(function requestAnimationFrame() {\n  let lastTime = 0;\n  const vendors = ['moz', 'ms', 'o', 'webkit'];\n\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[`${vendors[x]}RequestAnimationFrame`];\n    window.cancelAnimationFrame = window[`${vendors[x]}CancelAnimationFrame`] || window[`${vendors[x]}CancelRequestAnimationFrame`];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = (callback) => {\n      const currTime = new Date().getTime();\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      const id = window.setTimeout(() => {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n\n      lastTime = currTime + timeToCall;\n\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = (id) => {\n      clearTimeout(id);\n    };\n  }\n}());\n\n\nconst optimizedResize = (function optimizedResize() {\n  let callback;\n  let running = false;\n\n  const runCallback = function runCallback() {\n    callback();\n\n    running = false;\n  };\n\n  // fired on resize event\n  const throttledResize = function throttledResize() {\n    if (!running) {\n      running = true;\n\n      window.requestAnimationFrame(runCallback);\n    }\n  };\n\n  return {\n    addResizeListener: function addResizeListener(handleResize) {\n      window.addEventListener('resize', throttledResize);\n\n      callback = handleResize;\n    },\n    removeResizeListener: function removeResizeListener() {\n      window.removeEventListener('resize', throttledResize);\n    },\n  };\n}());\n\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\n\nconst parseSettings = function parseSettings(settings) {\n  if (!settings || typeof settings !== 'object') {\n    return;\n  }\n\n  // Default settings\n  const defaultSettings = {\n    // Initial zoom level\n    zoomLevel: 1,\n\n    // Minimum level to zoom\n    minZoomLevel: 0.125,\n\n    // Maximum level to zoom\n    maxZoomLevel: 32,\n\n    // Default factor to zoom in or out\n    zoomFactor: 2,\n\n    // Alignment of the content if it is smaller than the zoom container\n    alignment: {\n        horizontal: 'center', // left, center, right\n        vertical: 'center' // top, center, bottom\n    },\n\n    // CSS transition-timing-function\n    zoomEasing: 'ease-in-out',\n\n    // CSS transition-duration in milliseconds\n    zoomDuration: '300ms',\n\n    // Default point to zoom in or out\n    focalPoint: {\n      x: 0,\n      y: 0,\n    },\n\n    // updateOnResize: false,\n    // showScrollbars: true,\n\n    // onInit: function() {},\n    // onDestroy: function() {},\n    beforeZoomCallback: function() {},\n    afterZoomCallback: function() {}\n  };\n\n  let resultSettings = {};\n\n  // TODO: do type check and error alert\n  for (let prop in defaultSettings) {\n    if (hasOwnProp.call(defaultSettings, prop)) {\n      resultSettings[prop] = settings[prop] || defaultSettings[prop];\n    }\n  }\n\n  return resultSettings;\n};\n\n\n// TODO: cache prefixes\nconst setCSSStyles = function setCSSStyles(element, styles) {\n\n  for (let style in styles) {\n    if (hasOwnProp.call(styles, style)) {\n\n      if (element.style[style] !== undefined) {\n        element.style[style] = styles[style];\n      } else { // Check vendor prefixes\n        const vendorPrefixes = ['webkit', 'Moz', 'ms', 'O'];\n        const styleName = style[0].toUpperCase() + style.substr(1);\n\n        for (let prop in vendorPrefixes) {\n          if (hasOwnProp.call(vendorPrefixes, prop)) {\n            if (element.style[vendorPrefixes[prop] + styleName] !== undefined) {\n              element.style[vendorPrefixes[prop] + styleName] = styles[style];\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n\n// TODO: check compatibility (IE 9 dosn't support transition end event)\nconst getTransitionEndEvent = function getTransitionEndEvent() {\n  const element = document.createElement('div');\n  const transitions = {\n    transition: 'transitionend',\n    oTransition: 'oTransitionEnd',\n    mozTransition: 'transitionend',\n    webkitTransition: 'webkitTransitionEnd',\n  };\n  let transitionEndEvent;\n\n  for (let transition in transitions) {\n    if (element.style[transition] !== undefined) {\n      transitionEndEvent = transitions[transition];\n      break;\n    }\n  }\n\n  return transitionEndEvent;\n};\n\n\nconst valueBetween = function valueBetween(value, min, max) {\n  if (min > max) {\n    console.warn(`Warning: The minimum value ${min} is bigger than the the maximum value ${max}.`);\n  }\n\n  return (Math.min(max, Math.max(min, value)));\n};\n\n\nexport default class Awezoom {\n  constructor(element, settings) {\n    let zoomContainerElement;\n\n    // Get zoom container element\n    if (typeof element === 'string') {\n      zoomContainerElement = document.querySelector(element);\n    } else if (element.nodeType && element.nodeType === 1) {\n      zoomContainerElement = element;\n    }\n\n    // Ensure that the zoom container exist\n    if (!zoomContainerElement) {\n      console.warn('Warning: The zoom container element was not found.');\n\n      return;\n    }\n\n    // Parse settings\n    this.settings = parseSettings(settings);\n    \n    // TODO: Always wrap content when chrome mobile transition lag bug is solved\n    const children = zoomContainerElement.children;\n\n    // Wrap content if there is more than one child\n    if (children.length > 1) {\n      zoomContainerElement.innerHTML = `<div>${zoomContainerElement.innerHTML}</div>`;\n    }\n\n    // Get zoom content element\n    const zoomContentElement = children[0];\n\n    // Add a placeholder element\n    const placeholderElement = document.createElement('div');\n    zoomContainerElement.appendChild(placeholderElement);\n\n    // Place content into placeholder\n    placeholderElement.appendChild(zoomContentElement);\n\n    // TODO: Use when chrome mobile transition lag bug is solved \n    // // Prepare DOM\n    // zoomContainerElement.innerHTML = `<div><div>${zoomContainerElement.innerHTML}</div></div>`;\n\n    // // Get elements\n    // const placeholderElement = zoomContainerElement.children[0];\n    // const zoomContentElement = placeholderElement.children[0];\n\n    // Set initial styles\n    setCSSStyles(zoomContainerElement, {\n      overflow: 'scroll',\n      position: 'relative',\n    });\n    setCSSStyles(placeholderElement, {\n      position: 'absolute',\n      overflow: 'hidden',\n      transform: 'translateZ(0)'\n    });\n    setCSSStyles(zoomContentElement, {\n      position: 'absolute',\n      transformOrigin: '0 0 0'\n    });\n\n    // Cache internal state\n    this.state = {\n      zoomContainerElement,\n      zoomContentElement,\n      placeholderElement,\n      isZooming: false,\n      transitionEndEvent: getTransitionEndEvent(),\n      alignment: this.settings.alignment,\n      zoomLevel: this.settings.zoomLevel,\n      zoomContainerSize: {},\n      contentSize: {},\n      contentOffset: {\n        x: 0,\n        y: 0,\n      },\n      scrollPosition: {},\n    };\n\n    this.update();\n\n    // TODO: unbind after destroy\n    optimizedResize.addResizeListener(() => {\n      this.position();\n    });\n\n    // Set initial zoom level and position\n    this.zoom(this.state.zoomLevel, {\n      x: 0,\n      y: 0,\n    }, '0ms');\n  }\n\n  update() {\n    this.state.zoomContainerSize = this.calculateZoomContainerSize();\n    this.state.contentSize = this.calculateContentSize();\n\n    // TODO: check if necessary\n    this.state.scrollPosition = this.calculateScrollPosition();\n  }\n\n  position(zoomDuration = this.settings.zoomDuration, zoomEasing = this.settings.zoomEasing) {\n    this.update();\n\n    const currentZoomLevel = this.state.zoomLevel;\n    const currentZoomContainerSize = this.state.zoomContainerSize;\n    const currentContentSize = this.state.contentSize;\n    const targetContentOffset = this.determineIntendedContentOffset();\n\n    if (currentZoomContainerSize.width > currentContentSize.width) {\n      setCSSStyles(this.state.placeholderElement, {\n        width: '100%',\n      });\n    }\n\n    if (currentZoomContainerSize.height > currentContentSize.height) {\n      setCSSStyles(this.state.placeholderElement, {\n        height: '100%',\n      });\n    }\n\n    setCSSStyles(this.state.zoomContentElement, {\n      transitionDuration: zoomDuration,\n      transitionTimingFunction: zoomEasing,\n      transformOrigin: '0 0 0',\n      transform: `matrix(${currentZoomLevel}, 0, 0, ${currentZoomLevel}, ${targetContentOffset.x}, ${targetContentOffset.y})`,\n    });\n\n    setCSSStyles(this.state.placeholderElement, {\n      width: `${currentContentSize.width + targetContentOffset.x}px`,\n      height: `${currentContentSize.height + targetContentOffset.y}px`,\n    });\n\n    this.state.contentOffset = targetContentOffset;\n  }\n\n  // Zoom\n  zoom(zoomLevel = this.settings.zoomLevel, focalPoint = this.settings.focalPoint,\n    zoomDuration = this.settings.zoomDuration, zoomEasing = this.settings.zoomEasing, \n    beforeZoomCallback = this.settings.beforeZoomCallback, afterZoomCallback = this.settings.afterZoomCallback) {\n    if (this.state.isZooming) {\n      return;\n    }\n\n    if (zoomLevel < this.settings.minZoomLevel || zoomLevel > this.settings.maxZoomLevel) {\n      return;\n    }\n\n    this.state.isZooming = true;\n\n    // Call before zoom callback method\n    beforeZoomCallback();\n\n    this.update();\n\n    const currentZoomLevel = this.state.zoomLevel;\n    const currentContentOffset = this.state.contentOffset;\n    const currentContentSize = this.state.contentSize;\n    const currentScrollPosition = this.state.scrollPosition;\n    const zoomedContentSize = this.calculateContentSize(zoomLevel);\n    const targetTransformOrigin = this.determineTransformOrigin(focalPoint, currentZoomLevel, zoomLevel);\n    const contentOffsetAfterZooming = this.determineIntendedContentOffset(zoomLevel);\n\n    let transitionEndEvent;\n\n    // Calculate new scroll position\n    const zoomContainerSize = this.state.zoomContainerSize;\n    const focalPointInZoomedContent = this.findRawCoordinatesInZoomedContent(targetTransformOrigin, zoomLevel);\n    const viewportCoordinates = this.findRawCoordinatesInViewport(targetTransformOrigin);\n    const maxScrollPosition = {\n      x: (zoomedContentSize.width - zoomContainerSize.width > 0) ? (zoomedContentSize.width - zoomContainerSize.width) : 0,\n      y: (zoomedContentSize.height - zoomContainerSize.height > 0) ? (zoomedContentSize.height - zoomContainerSize.height) : 0,\n    };\n    const newScrollPosition = {\n      x: valueBetween(focalPointInZoomedContent.x - viewportCoordinates.x, 0, maxScrollPosition.x),\n      y: valueBetween(focalPointInZoomedContent.y - viewportCoordinates.y, 0, maxScrollPosition.y),\n    };\n\n    // Calculate new offset\n    const transformOffsetToCompensateOrigin = { // Compensate origin\n      x: (targetTransformOrigin.x * currentZoomLevel) - targetTransformOrigin.x,\n      y: (targetTransformOrigin.y * currentZoomLevel) - targetTransformOrigin.y,\n    };\n    const transformOffset = {\n      x: transformOffsetToCompensateOrigin.x + currentContentOffset.x,\n      y: transformOffsetToCompensateOrigin.y + currentContentOffset.y,\n    };\n\n    // On zoom in: resize placeholder element to stretch content for scrolling\n    if (zoomLevel > currentZoomLevel) {\n      transformOffset.x += newScrollPosition.x - currentScrollPosition.x;\n      transformOffset.y += newScrollPosition.y - currentScrollPosition.y;\n\n      setCSSStyles(this.state.placeholderElement, {\n        width: `${zoomedContentSize.width + contentOffsetAfterZooming.x}px`,\n        height: `${zoomedContentSize.height + contentOffsetAfterZooming.y}px`,\n      });\n\n      this.setScrollPosition(newScrollPosition);\n\n    // On zoom out: resize placeholder to remain content size until transition has ended\n    } else {\n      setCSSStyles(this.state.placeholderElement, {\n        width: `${currentContentSize.width + currentContentOffset.x}px`,\n        height: `${currentContentSize.height + currentContentOffset.y}px`,\n      });\n    }\n\n    // Function to call after transition has ended\n    const afterTransition = () => {\n      // Reinsert content\n      setCSSStyles(this.state.zoomContentElement, {\n        transitionDuration: '',\n        transitionTimingFunction: '',\n        transformOrigin: '0 0 0',\n        transform: `matrix(${zoomLevel}, 0, 0, ${zoomLevel}, ${contentOffsetAfterZooming.x}, ${contentOffsetAfterZooming.y})`,\n      });\n\n      // On zoom out resize placeholder and scroll after transition\n      if (zoomLevel <= currentZoomLevel) {\n        setCSSStyles(this.state.placeholderElement, {\n          width: `${zoomedContentSize.width + contentOffsetAfterZooming.x}px`,\n          height: `${zoomedContentSize.height + contentOffsetAfterZooming.y}px`,\n        });\n\n        this.setScrollPosition(newScrollPosition);\n      }\n\n      // Remove event listener\n      if (transitionEndEvent) {\n        this.state.zoomContentElement.removeEventListener(transitionEndEvent, afterTransition, false);\n      }\n\n      // Update states\n      this.state.zoomLevel = zoomLevel;\n      this.state.contentSize = zoomedContentSize;\n      this.state.contentOffset = contentOffsetAfterZooming;\n\n      this.state.isZooming = false;\n\n      // Call after zoom callback method\n      afterZoomCallback();\n    };\n\n    if (zoomDuration.replace(/[^\\d\\.,]/g, '') <= 0 || currentZoomLevel === zoomLevel) {\n      // Call manually if there is no transition event\n      afterTransition();\n    } else {\n      transitionEndEvent = this.state.transitionEndEvent;\n\n      // Position content and set focal point\n      setCSSStyles(this.state.zoomContentElement, {\n        transitionDuration: '',\n        transitionTimingFunction: '',\n        transformOrigin: `${targetTransformOrigin.x}px ${targetTransformOrigin.y}px 0`,\n        transform: `matrix(${currentZoomLevel}, 0, 0, ${currentZoomLevel}, ${transformOffset.x}, ${transformOffset.y})`,\n      });\n\n      this.triggerReflow();\n\n      // Add event listener to execute afterTransition()\n      this.state.zoomContentElement.addEventListener(transitionEndEvent, afterTransition, false);\n\n      // Zoom the content\n      setCSSStyles(this.state.zoomContentElement, {\n        transitionDuration: zoomDuration,\n        transitionTimingFunction: zoomEasing,\n        transform: `matrix(${zoomLevel}, 0, 0, ${zoomLevel}, ${transformOffset.x}, ${transformOffset.y})`,\n      });\n    }\n  }\n\n  zoomIn(focalPoint, zoomDuration, zoomEasing) {\n    this.zoom(this.state.zoomLevel * this.settings.zoomFactor, focalPoint, zoomDuration, zoomEasing);\n  }\n\n  zoomOut(focalPoint, zoomDuration, zoomEasing) {\n    this.zoom(this.state.zoomLevel / this.settings.zoomFactor, focalPoint, zoomDuration, zoomEasing);\n  }\n\n  zoomToFit(zoomDuration, zoomEasing) {\n    const zoomContainerSize = this.state.zoomContainerSize;\n    const unzoomedContentSize = this.calculateContentSize(1);\n    const widthFactor = zoomContainerSize.width / unzoomedContentSize.width;\n    const heightFactor = zoomContainerSize.height / unzoomedContentSize.height;\n\n    let zoomLevel;\n\n    if (widthFactor < heightFactor) {\n      zoomLevel = widthFactor;\n    } else {\n      zoomLevel = heightFactor;\n    }\n\n    this.zoom(zoomLevel, {\n      x: 0,\n      y: 0,\n    }, zoomDuration, zoomEasing);\n  }\n\n  triggerReflow() {\n    // Trigger a reflow to set the transform matrix above before using a transition\n    return this.state.zoomContentElement.offsetHeight;\n  }\n\n  calculateZoomContainerSize() {\n    const element = this.state.zoomContainerElement;\n\n    // the inner size of an element including the padding\n    return {\n      width: element.clientWidth,\n      height: element.clientHeight,\n    };\n  }\n\n  calculateContentSize(zoomLevel = this.state.zoomLevel) {\n    const element = this.state.zoomContentElement;\n\n    // offsetWidth and offsetHeight is the size of an element including padding,\n    // borders and scrollbars the size isn't affected by CSS transformations,\n    // so it returns the original size\n    return {\n      width: element.offsetWidth * zoomLevel,\n      height: element.offsetHeight * zoomLevel,\n    };\n  }\n\n  findViewportCoordinatesInRawContent(coordinates) {\n    const currentScrollPosition = this.state.scrollPosition;\n    const contentOffset = this.state.contentOffset;\n    const currentZoomLevel = this.state.zoomLevel;\n    const unzoomedContentSize = this.calculateContentSize(1);\n\n    const coordinatesInUnzoomedContent = {\n      x: (coordinates.x + currentScrollPosition.x - contentOffset.x) / currentZoomLevel,\n      y: (coordinates.y + currentScrollPosition.y - contentOffset.y) / currentZoomLevel,\n    };\n\n    return {\n      x: valueBetween(coordinatesInUnzoomedContent.x, 0, unzoomedContentSize.width),\n      y: valueBetween(coordinatesInUnzoomedContent.y, 0, unzoomedContentSize.height),\n    };\n  }\n\n  findRawCoordinatesInViewport(coordinates) {\n    const currentZoomLevel = this.state.zoomLevel;\n    const currentContentOffset = this.state.contentOffset;\n    const currentScrollPosition = this.state.scrollPosition;\n\n    return {\n      x: (coordinates.x * currentZoomLevel) + (currentContentOffset.x - currentScrollPosition.x),\n      y: (coordinates.y * currentZoomLevel) + (currentContentOffset.y - currentScrollPosition.y),\n    };\n  }\n\n  findRawCoordinatesInZoomedContent(coordinates, zoomLevel) {\n    return {\n      x: coordinates.x * zoomLevel,\n      y: coordinates.y * zoomLevel,\n    };\n  }\n\n  calculateScrollPosition() {\n    const element = this.state.zoomContainerElement;\n\n    return {\n      x: element.scrollLeft,\n      y: element.scrollTop,\n    };\n  }\n\n  setScrollPosition(coordinates) {\n    const element = this.state.zoomContainerElement;\n\n    // Scroll\n    element.scrollLeft = coordinates.x;\n    element.scrollTop = coordinates.y;\n\n    // Update state\n    this.state.scrollPosition = coordinates;\n  }\n\n  determineIntendedContentOffset(zoomLevel = this.state.zoomLevel) {\n    const zoomContainerSize = this.state.zoomContainerSize;\n    const alignmentSettings = this.state.alignment;\n    const zoomedContentSize = this.calculateContentSize(zoomLevel);\n\n    const availableSpace = {\n      width: zoomContainerSize.width - zoomedContentSize.width,\n      height: zoomContainerSize.height - zoomedContentSize.height,\n    };\n\n    const contentOffset = {\n      x: 0,\n      y: 0,\n    };\n\n    if (availableSpace.width > 0) {\n      switch (alignmentSettings.horizontal) {\n        case 'left': {\n          contentOffset.x = 0;\n          break;\n        }\n        case 'right': {\n          contentOffset.x = availableSpace.width;\n          break;\n        }\n        case 'center':\n        default: {\n          contentOffset.x = availableSpace.width / 2;\n        }\n      }\n    }\n\n    if (availableSpace.height > 0) {\n      switch (alignmentSettings.vertical) {\n        case 'top': {\n          contentOffset.y = 0;\n          break;\n        }\n        case 'bottom': {\n          contentOffset.y = availableSpace.height;\n          break;\n        }\n        case 'center':\n        default: {\n          contentOffset.y = availableSpace.height / 2;\n        }\n      }\n    }\n\n    return contentOffset;\n  }\n\n  determineContentMargin(zoomLevel, focalPoint) {\n    const zoomContainerSize = this.state.zoomContainerSize;\n    const zoomedContentSize = this.calculateContentSize(zoomLevel);\n    const focalPointInUnzoomedContent = this.findViewportCoordinatesInRawContent(focalPoint);\n    const focalPointInZoomedContent = this.findRawCoordinatesInZoomedContent(focalPointInUnzoomedContent, zoomLevel);\n\n    const zoomContainerSizeAroundFocalPoint = {\n      top: focalPoint.y,\n      right: zoomContainerSize.width - focalPoint.x,\n      bottom: zoomContainerSize.height - focalPoint.y,\n      left: focalPoint.x,\n    };\n\n    const contentSizeAroundFocalPointAfterZooming = {\n      top: focalPointInZoomedContent.y,\n      right: zoomedContentSize.width - focalPointInZoomedContent.x,\n      bottom: zoomedContentSize.height - focalPointInZoomedContent.y,\n      left: focalPointInZoomedContent.x,\n    };\n\n    return {\n      top: zoomContainerSizeAroundFocalPoint.top - contentSizeAroundFocalPointAfterZooming.top,\n      right: zoomContainerSizeAroundFocalPoint.right - contentSizeAroundFocalPointAfterZooming.right,\n      bottom: zoomContainerSizeAroundFocalPoint.bottom - contentSizeAroundFocalPointAfterZooming.bottom,\n      left: zoomContainerSizeAroundFocalPoint.left - contentSizeAroundFocalPointAfterZooming.left,\n    };\n  }\n\n  determineTransformOrigin(focalPoint, currentZoomLevel, newZoomLevel) {\n    const currentContentOffset = this.state.contentOffset;\n    const alignmentSettings = this.state.alignment;\n    const zoomContainerSize = this.state.zoomContainerSize;\n    const unzoomedContentSize = this.calculateContentSize(1);\n    const currentContentSize = this.calculateContentSize(currentZoomLevel);\n    const zoomedContentSize = this.calculateContentSize(newZoomLevel);\n    const zoomFactor = newZoomLevel / currentZoomLevel;\n\n    // Ensure that focal point isn't out of content\n    const targetFocalPoint = {\n      x: valueBetween(focalPoint.x, currentContentOffset.x, currentContentSize.width + currentContentOffset.x),\n      y: valueBetween(focalPoint.y, currentContentOffset.y, currentContentSize.height + currentContentOffset.y),\n    };\n\n    const contentMarginAfterZooming = this.determineContentMargin(newZoomLevel, targetFocalPoint);\n    const transformOrigin = this.findViewportCoordinatesInRawContent(targetFocalPoint);\n\n    // Position content when smaller than the zoom area\n    // but just if the content size is smaller than the zoom container size, before and after transition\n    if (currentContentSize.width < zoomContainerSize.width && zoomedContentSize.width < zoomContainerSize.width) {\n      switch (alignmentSettings.horizontal) {\n        case 'left': {\n          transformOrigin.x = 0;\n          break;\n        }\n        case 'right': {\n          transformOrigin.x = unzoomedContentSize.width;\n          break;\n        }\n        case 'center':\n        default: {\n          transformOrigin.x = unzoomedContentSize.width / 2;\n        }\n      }\n\n    // Adjust position on zoom out if the content size is bigger than the zoom container size, before and after transition\n    // and if there is a positive margin on just one side\n    // or when the content size trespasses the zoom container size and if there is a positive margin on just one side\n    } else if (zoomedContentSize.width >= zoomContainerSize.width) {\n      if (contentMarginAfterZooming.right > 0) {\n        transformOrigin.x -= contentMarginAfterZooming.right / (zoomFactor - 1) / currentZoomLevel;\n      }\n\n      if (contentMarginAfterZooming.left > 0) {\n        transformOrigin.x += contentMarginAfterZooming.left / (zoomFactor - 1) / currentZoomLevel;\n      }\n\n    // Adjust position on zoom out when the content size trespasses the zoom container size\n    } else if (currentContentSize.width >= zoomContainerSize.width && zoomedContentSize.width <= zoomContainerSize.width) {\n      switch (alignmentSettings.horizontal) {\n        case 'left': {\n          transformOrigin.x += contentMarginAfterZooming.left / (zoomFactor - 1) / currentZoomLevel;\n          break;\n        }\n        case 'right': {\n          transformOrigin.x -= contentMarginAfterZooming.right / (zoomFactor - 1) / currentZoomLevel;\n          break;\n        }\n        case 'center':\n        default: {\n          transformOrigin.x -= (contentMarginAfterZooming.right - contentMarginAfterZooming.left) / (zoomFactor - 1) / currentZoomLevel / 2;\n        }\n      }\n    }\n\n    // Position content when smaller than the zoom area\n    // but just if the content size is smaller than the zoom container size, before and after transition\n    if (currentContentSize.height < zoomContainerSize.height && zoomedContentSize.height < zoomContainerSize.height) {\n      switch (alignmentSettings.vertical) {\n        case 'top': {\n          transformOrigin.y = 0;\n          break;\n        }\n        case 'bottom': {\n          transformOrigin.y = unzoomedContentSize.height;\n          break;\n        }\n        case 'center':\n        default: {\n          transformOrigin.y = unzoomedContentSize.height / 2;\n        }\n      }\n\n    // Adjust position on zoom out if the content size is bigger than the zoom container size, before and after transition\n    // and if there is a positive margin on just one side\n    // or when the content size trespasses the zoom container size and if there is a positive margin on just one side\n    } else if (zoomedContentSize.height >= zoomContainerSize.height) {\n      if (contentMarginAfterZooming.bottom > 0) {\n        transformOrigin.y -= contentMarginAfterZooming.bottom / (zoomFactor - 1) / currentZoomLevel;\n      }\n\n      if (contentMarginAfterZooming.top > 0) {\n        transformOrigin.y += contentMarginAfterZooming.top / (zoomFactor - 1) / currentZoomLevel;\n      }\n\n    // Adjust position on zoom out when the content size trespasses the zoom container size\n    } else if (currentContentSize.height >= zoomContainerSize.height && zoomedContentSize.height <= zoomContainerSize.height) {\n      switch (alignmentSettings.vertical) {\n        case 'top': {\n          transformOrigin.y += contentMarginAfterZooming.top / (zoomFactor - 1) / currentZoomLevel;\n          break;\n        }\n        case 'bottom': {\n          transformOrigin.y -= contentMarginAfterZooming.bottom / (zoomFactor - 1) / currentZoomLevel;\n          break;\n        }\n        case 'center':\n        default: {\n          transformOrigin.y -= (contentMarginAfterZooming.bottom - contentMarginAfterZooming.top) / (zoomFactor - 1) / currentZoomLevel / 2;\n        }\n      }\n    }\n\n    return transformOrigin;\n  }\n\n  pinch(pinchEventType, focalPoint, scale) {\n    switch (pinchEventType) {\n      case 'pinchstart': {\n        if (this.state.isZooming) {\n          return;\n        }\n\n        this.state.isZooming = true;\n\n        this.update();\n\n        const currentZoomLevel = this.state.zoomLevel;\n        const currentZoomContainerSize = this.state.zoomContainerSize;\n        const currentContentSize = this.state.contentSize;\n        const currentContentOffset = this.state.contentOffset;\n        const transformOrigin = this.findViewportCoordinatesInRawContent(focalPoint);\n        const transformOffsetToCompensateOrigin = { // Compensate origin\n          x: (transformOrigin.x * currentZoomLevel) - transformOrigin.x,\n          y: (transformOrigin.y * currentZoomLevel) - transformOrigin.y,\n        };\n        const transformOffset = {\n          x: transformOffsetToCompensateOrigin.x + currentContentOffset.x,\n          y: transformOffsetToCompensateOrigin.y + currentContentOffset.y,\n        };\n\n        if (currentZoomContainerSize.width > currentContentSize.width) {\n          setCSSStyles(this.state.placeholderElement, {\n            width: '100%',\n          });\n        }\n\n        if (currentZoomContainerSize.height > currentContentSize.height) {\n          setCSSStyles(this.state.placeholderElement, {\n            height: '100%',\n          });\n        }\n\n        // Position content and set focal point\n        setCSSStyles(this.state.zoomContentElement, {\n          transitionDuration: '',\n          transitionTimingFunction: '',\n          transformOrigin: `${transformOrigin.x}px ${transformOrigin.y}px 0`,\n          transform: `matrix(${currentZoomLevel}, 0, 0, ${currentZoomLevel}, ${transformOffset.x}, ${transformOffset.y})`,\n        });\n\n        this.state.lastPinchFocalPoint = focalPoint;\n        this.state.lastPinchOffset = transformOffset;\n        this.state.lastPinchOrigin = transformOrigin;\n        this.state.lastPinchZoomLevel = currentZoomLevel;\n\n        break;\n      }\n      case 'pinchmove': {\n        const zoomLevel = scale * this.state.zoomLevel;\n\n        if (zoomLevel < this.settings.minZoomLevel || zoomLevel > this.settings.maxZoomLevel) {\n          return;\n        }\n\n        // Zoom\n        setCSSStyles(this.state.zoomContentElement, {\n          transform: `matrix(${zoomLevel}, 0, 0, ${zoomLevel}, ${this.state.lastPinchOffset.x}, ${this.state.lastPinchOffset.y})`,\n        });\n\n        this.state.lastPinchZoomLevel = zoomLevel;\n\n        break;\n      }\n      case 'pinchend':\n      default: {\n        if (!this.state.isZooming) {\n          return;\n        }\n\n        const zoomEasing = this.settings.zoomEasing;\n        const zoomDuration = this.settings.zoomDuration;\n        const zoomLevel = this.state.lastPinchZoomLevel;\n\n        const transitionEndEvent = this.state.transitionEndEvent;\n        const zoomContainerSize = this.state.zoomContainerSize;\n        const zoomedContentSize = this.calculateContentSize(zoomLevel);\n\n        // Calculate Offset\n        const contentOffsetAfterZooming = this.determineIntendedContentOffset(zoomLevel);\n        const contentMarginAfterZooming = this.determineContentMargin(zoomLevel, this.state.lastPinchFocalPoint);\n        const transformOffset = {\n          x: this.state.lastPinchOffset.x,\n          y: this.state.lastPinchOffset.y,\n        };\n\n        if (zoomedContentSize.width > zoomContainerSize.width) {\n          transformOffset.x -= contentMarginAfterZooming.left > 0 ? contentMarginAfterZooming.left : 0;\n          transformOffset.x += contentMarginAfterZooming.right > 0 ? contentMarginAfterZooming.right : 0;\n        } else {\n          transformOffset.x += (contentOffsetAfterZooming.x - contentMarginAfterZooming.left);\n        }\n\n        if (zoomedContentSize.height > zoomContainerSize.height) {\n          transformOffset.y -= contentMarginAfterZooming.top > 0 ? contentMarginAfterZooming.top : 0;\n          transformOffset.y += contentMarginAfterZooming.bottom > 0 ? contentMarginAfterZooming.bottom : 0;\n        } else {\n          transformOffset.y += (contentOffsetAfterZooming.y - contentMarginAfterZooming.top);\n        }\n\n        // Calculate scroll position\n        const focalPointInZoomedContent = this.findRawCoordinatesInZoomedContent(this.state.lastPinchOrigin, zoomLevel);\n        const viewportCoordinates = this.state.lastPinchFocalPoint;\n        const maxScrollPosition = {\n          x: (zoomedContentSize.width - zoomContainerSize.width > 0) ? (zoomedContentSize.width - zoomContainerSize.width) : 0,\n          y: (zoomedContentSize.height - zoomContainerSize.height > 0) ? (zoomedContentSize.height - zoomContainerSize.height) : 0,\n        };\n        const newScrollPosition = {\n          x: valueBetween(focalPointInZoomedContent.x - viewportCoordinates.x, 0, maxScrollPosition.x),\n          y: valueBetween(focalPointInZoomedContent.y - viewportCoordinates.y, 0, maxScrollPosition.y),\n        };\n\n        // Function to call after transition has ended\n        const afterTransition = () => {\n          // Reinsert content\n          setCSSStyles(this.state.zoomContentElement, {\n            transitionDuration: '',\n            transitionTimingFunction: '',\n            transformOrigin: '0 0 0',\n            transform: `matrix(${zoomLevel}, 0, 0, ${zoomLevel}, ${contentOffsetAfterZooming.x}, ${contentOffsetAfterZooming.y})`,\n          });\n\n          setCSSStyles(this.state.placeholderElement, {\n            width: `${zoomedContentSize.width + contentOffsetAfterZooming.x}px`,\n            height: `${zoomedContentSize.height + contentOffsetAfterZooming.y}px`,\n          });\n\n          this.setScrollPosition(newScrollPosition);\n\n          // Remove event listener\n          if (transitionEndEvent) {\n            this.state.zoomContentElement.removeEventListener(transitionEndEvent, afterTransition, false);\n          }\n\n          // Update states\n          this.state.zoomLevel = zoomLevel;\n          this.state.contentOffset = contentOffsetAfterZooming;\n\n          this.state.lastPinchFocalPoint = null;\n          this.state.lastPinchOffset = null;\n          this.state.lastPinchOrigin = null;\n          this.state.lastPinchZoomLevel = null;\n\n          this.state.isZooming = false;\n        };\n\n        if (this.state.lastPinchOffset.x !== transformOffset.x || this.state.lastPinchOffset.y !== transformOffset.y) {\n          // Add event listener to execute afterTransition()\n          this.state.zoomContentElement.addEventListener(transitionEndEvent, afterTransition, false);\n\n          // Move to correct position\n          setCSSStyles(this.state.zoomContentElement, {\n            transitionDuration: zoomDuration,\n            transitionTimingFunction: zoomEasing,\n            transform: `matrix(${zoomLevel}, 0, 0, ${zoomLevel}, ${transformOffset.x}, ${transformOffset.y})`,\n          });\n        } else {\n          afterTransition();\n        }\n      }\n    }\n  }\n}\n"],"sourceRoot":""}